# Clean Architecture Temel Prensiplere sahip olmalıdır:
	 # Dependency Inversion
		# High level modül low level modüle direkt bağlı olmayacak. Arada interface, abstract class olabilir.
		# Soyutlamalar detaylar üzerine gerçekleşmeyecek.
			# GetProductsFromCache ❌
			# GetProducts ✅
	 # Inversion Of Control
		# Low level modül High level modül içerisine "new" anahtar kelimesi ile değil CTOR , METHOD veya PROPERTY injection ile gelebilir.
	 # Single Responsibility
		# 
		# Bir component değişmesi için bir nedene sahip olmalıdır.
		# Event Based Architecture, Observer Design Pattern, MediatR Design Pattern ile SRP'a uygun hale gelebiliriz.
	 # Persistence Ignorance
		# "Şimdilik bilmen gerekmeyen şeyi bilme, bağımlılık yaratma"
	 # Separation Of Concern
		# Kodlar ilgi alanlarına göre birbirlerinden ayrılır. Hepsinin üstünde bir prensiptir.

# N-Layer architecture problems:
	# Service katmanı SRP prensibini ihlal eder. Çünkü deüişmesi için kendisi dışında birden fazla neden olabilir. e.g Repository Layer
	# Bu sebeple infastructure logic'i (repository layer, cache layer, queue layer) en üste taşırsak bu problemi ortadan kaldırıyoruz.
		# Burada infastructure katmanları service layer'ı referans alacak. Bu sefer ise service katmanı repository layer'ı referans
		  almadığı için kodlarını kullanamayacak. Burada devreye inversion of control prensibi devreye girer. İnterface'ler service 
		  katmanında yazılır implemantasyonları ise ilgili katmanda tanımlanır.


# Clean Architecture'da flow yukarıdan aşağıya doğrudur.
	# User Interfaces - Infastucture - Persistence
		# Interface implementations, Data Access, Bus, Cache, File Write/Read, API, MVC Pages, Middlewares, Filters
	# Application
		# Business Codes, Interfaces
		# Application 
	# Domain
		# Entities, Interfaces, Exceptions


# SOURCES
	- https://github.com/jasontaylordev/CleanArchitecture/tree/main
		- Bu proje ile clean architecture best practice'lerini görebiliriz.
	- https://medium.com/@roshanj100/implementing-redis-caching-in-clean-architecture-with-net-8-and-mediatr-600bc2e07ac5
		- Redis caching'in clean architecture ile nasıl entegre edileceğini anlatıyor.


# TODO
	# Önce entity'ler içerisindeki User problemi çözülür. ✅
	# Identity API ile üyelik sistemi eklenir. ✅
	# DTO nesneleri oluşturulur.
	# FluentValidation ve Mapster library'leri application katmanda yüklenir.
	# Her bir DTO (request) nesnesi için fluent validation ile kurallar yazılır.
	  # Entity'lere ait ayrı ayrı klasörler application içerisinde Features klasörü altında olacak. 
	      # Burada o entity için gerekli dto'lar ve validation kuralları yazılır. Ayrıca Service interface'i , implemantasyonu ve mapping
		    profile'ı burada bulunur.
	# Her bir entity için gerekli repository interface'leri yazılır.
	  # Bu repository'ler application projesi altında Contracts / persistence içerisine yazılır. Çünkü veritabanı ile alakalıdır.
	# Kendi özel yazdığım exception'lar domain katmanında olacakken exception handler'lar başka yerde olacak.
	# MediatR + CQRS Pattern bu projeye implement edilir.
		# AYRI BİR BRANCH İÇERİSİNDE BU PROJELER TAMAMLANDIKTAN SONRA
	# ŞUAN İÇİN OPENTELEMETRY SADECE MANUEL OLARAK EKLENECEK. BURADAKİ API ENDPOINTLER YAZILDIKTAN VE NEXT.JS
	  TARAFI TAMAMLANDIKTAN SONRA DOCKER İLE AUTO INSTRUMENTATION EKLENECEK.
		# TRACE --> Jaeger
		# METRICS --> Prometheus
		# LOGS --> Elasticsearch
	# REDIS İLE CACHING ALTYAPISI EKLENECEK.


	domain
	- entitites ✅
	- events --> İhtiyaç duyuldukça buraya yazılacak
	- exceptions  --> İhtiyaç duyuldukça buraya yazılacak
	- options --> ✅

	application
	- repository contracts --> Contracts/Persistence  --> İhtiyaç duyuldukça buraya yazılacak
	- service extension --> içi doldurulacak
	- application assembly --> ✅
	- service result ✅
	- Features
		- DTO Files
		- Validators
		- Mapping Files
		- repository service interface and implementation

	persistence
	- AppDbContext ✅
	- Entity configuration files ✅
	- repository interface implementation 
	- repository extension
	- interceptors
	- migrations
	- persistence assembly ✅
	- IGenericRepository implementation ✅
	- UnitOfWork implementation ✅

	
	API
	- ExceptionHandlers
	- Extensions
	- Filters
	- Program.cs
		- JWT Bearer authentication ✅
		- Services --> eklenecek
		- Repositories --> eklenecek
		- MapsterConfiguration ✅




_____________________________________________________________________________________________________________________

# OPENTELEMETRY
	# OpenTelemetry ile birlikte tracing, metrics ve logging verilerini toplayabiliyoruz.
	# İlgili kaynaklar
		# https://github.com/open-telemetry/opentelemetry-dotnet
		# https://github.com/open-telemetry/opentelemetry-dotnet-contrib
		# https://github.com/open-telemetry/opentelemetry-dotnet-instrumentation --> Automatic Instrumentation
	

	API PROJESİ İÇERİSİNDE APPSETTING.DEVELOPMENT İÇERİSİNE OPENTELEMETRY RESOURCE BİLGİLERİ EKLENECEK.
	Domain projesi içerisine OpenTelemetryConstantOption eklenecek.
	INFRASTRUCTURE İÇERİSİNDE ACTIVITY SOURCE PROVIDER TANIMLANACAK.
	API PROJESİ İÇERİSİNDE PROGRAM.CS İÇERİSİNDE 


	ASP NET CORE INSTRUMENTATION
	# API VEYA MVC UYGULAMAMIZA GELEN REQUEST VE RESPONSE'LARI OTOMATIK OLARAK TRACE ETMEMİZE OLANAK SAĞLAR.
	10. adım --> sadece /api ile başlayan route'ları trace etmek için
	12. adım --> request response'a dönene kadar fırlayan hataları trace data içerisinde görmek için
	18. adım --> activity'lere tag nasıl eklenir örneği
	22. adım --> Request ve response body'lerini var olan aktiviteye eklemek için middleware yazılır.
		# BİZE GELEN REQUEST'LERİ VE BİZİM YAZDIĞIMIZ RESPONSE'LARI TRACE OLARAK BODY'E EKLER.


	EF CORE INSTRUMENTATION
	# UYGULAMAMIZIN VERİTABANINA YAPMIŞ OLDUĞU TRANSACTION'LARI TRACE DATA OLARAK ELE ALMAMIZA OLANAK SAĞLAR.

	HTTP INSTRUMENTATION
	# MVC VEYA API UYGULAMAMIZDAN BAŞKA EXTERNAL API'LERE YAPMIŞ OLDUĞUMUZ REQUEST'LERI TRACE ETMEMIZE OLANAK SAĞLAR.
		# HTTP CLIENT INSTRUMENTATION BİZİM GÖNDERDİĞİMİZ REQUEST'LERİ VE BİZE GELEN RESPONSE'LARI TRACE OLARAK BODY'E EKLER.


	REDIS INSTRUMENTATION
	# API'MİZDEN REDIS'E YAPMIŞ OLDUĞUMUZ İSTEKLERİN TRACE EDİLMESİNİ SAĞLAR.


	# COPILOT'A BİR KODUN ARASINDAKİ İLİŞKİYİ # İLE DOSYALARI EKLEYİP "MERMAID DIAGRAM" ÇİZMESİNİ İSTEYEREK ANLATTIRABİLİRİZ.
	# ÖZELLİKLE OPEN SOURCE INFRASTRUCTURE SAĞLAYAN PROJELER İÇİN BU ÇOK KULLANIŞLI OLABİLİR.


	___________________________________________________________________________________________________________________________________________

	# EVENT BASED INVALIDATION

		# CacheEventConsumer --> Cache invalidation işlemlerini merkezi hale getirir.
				# Events
					# EntityInsertedEvent		(+) App.Domain.Events									(+)
					# EntityUpdatedEvent		(+) App.Domain.Events									(+)
					# EntityDeletedEvent		(+) App.Domain.Events									(+)

	# RESET INVALIDATION
		# IScheduledTask						(+) App.Application.Contracts.Infrastructure.Tasks		(+)
		# ClearCacheTask						(+) App.Infrastructure.Caching							(+)


	# REDIS DISTRIBUTED CACHING
		# IRedisConnectionWrapper																		(+)
		# RedisConnectionWrapper																		(+)
		# RedisCacheManager																				(+)


	# LOCKER MECHANISM
		# ILocker								(+) App.Application.Contracts.Infrastructure.Caching	(+)
		# DistributedCacheLocker				(+) App.Infrastructure.Caching							(+)
		# MemoryCacheLocker					    (+) App.Infrastructure.Caching							(+)


	# CACHE MANAGERS
		# IShortTermCacheManager				(+) App.Application.Contracts.Infrastructure.Caching	(+)
			# PerRequestCacheManager			(+) App.Infrastructure.Caching							(+)
		# IStaticCacheManager					(+) App.Application.Contracts.Infrastructure.Caching	(+)
			# MemoryCacheManager				(+) App.Infrastructure.Caching							(+)
			# DistributedCacheManager			(+) App.Infrastructure.Caching							(+)
			# SynchronizedCacheManager			(-) şu an gerek yok


	# CACHE KEY GENERATOR
		# ICacheKey								(+) App.Application.Contracts.Infrastructure.Caching	(+)
		# CacheKey								(+) App.Infrastructure.Caching							(+)	
		# ICacheKeyFactory						(+) App.Application.Contracts.Infrastructure.Caching	(+)
		# CacheKeyFactory						(+) App.Infrastructure.Caching							(+)
		# ICacheKeyService						(+) App.Application.Contracts.Infrastructure.Caching	(+)
		# CacheKeyService						(+) App.Infrastructure.Caching							(+)
		# ICacheKeyManager						(+) App.Application.Contracts.Infrastructure.Caching	(+)
		# CacheKeyManager						(+) App.Infrastructure.Caching							(+)


	ICacheKeyStore<TValue>						(+) App.Application.Contracts.Infrastructure.Caching	(+)
	CacheKeyStore								(+) App.Infrastructure.Caching							(+)
	CacheConfig									(+) App.Domain.Options / appsettings.json				(+)
	DistributedCacheConfig						(+) App.Domain.Options / appsettings.json				(+)
	DistributedCacheType						(-) Şu an gerek yok
	HashHelper									(+) App.Infrastructure.Security							(+)


